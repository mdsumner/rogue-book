<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Michael D. Sumner" />

<meta name="date" content="2016-01-11" />

<title>Rogue GIS</title>

<script src="libs/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.1/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.1/shim/respond.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link rel="stylesheet" href="style.css" type="text/css" />

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
</style>
</head>

<body>

<div class="container-fluid main-container">


<!--token:title:start-->
<div id="header">
<h1 class="title">Rogue GIS</h1>
<h4 class="author"><em>Michael D. Sumner</em></h4>
<h4 class="date"><em>2016-01-11</em></h4>
</div>
<!--token:title:end-->

<!--token:toc:start-->
<div id="TOC">
<ul>
<li><a href="#prerequisites"><span class="toc-section-number">1</span> Prerequisites</a></li>
<li><a href="#intro"><span class="toc-section-number">2</span> Introduction</a></li>
<li><a href="#poly3"><span class="toc-section-number">3</span> Polygons in 3d</a><ul>
<li><a href="#gis-for-3d"><span class="toc-section-number">3.1</span> GIS for 3D</a></li>
<li><a href="#polygon-layer"><span class="toc-section-number">3.2</span> Polygon “layer”</a></li>
<li><a href="#opengl-in-r"><span class="toc-section-number">3.3</span> OpenGL in R</a></li>
<li><a href="#organization-of-polygons"><span class="toc-section-number">3.4</span> Organization of polygons</a></li>
<li><a href="#more-3d-already"><span class="toc-section-number">3.5</span> More 3D already!</a></li>
<li><a href="#github-sfr"><span class="toc-section-number">3.6</span> Github, sfr</a></li>
<li><a href="#image-textures"><span class="toc-section-number">3.7</span> Image textures</a></li>
<li><a href="#polygon-pathologies"><span class="toc-section-number">3.8</span> Polygon pathologies</a></li>
<li><a href="#real-world-topography"><span class="toc-section-number">3.9</span> Real world topography</a></li>
</ul></li>
</ul>
</div>
<!--token:toc:end-->

<!--token:body:start-->
<div id="prerequisites" class="section level1">
<h1><span class="header-section-number">1</span> Prerequisites</h1>
<p>See here for how this book was made: <a href="http://rstudio.github.io/bookdown/" class="uri">http://rstudio.github.io/bookdown/</a></p>
<p>For now, you have to install the development versions of <strong>bookdown</strong>, <strong>rmarkdown</strong>, and <strong>knitr</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(
  <span class="kw">c</span>(<span class="st">&quot;bookdown&quot;</span>, <span class="st">&quot;knitr&quot;</span>),
  <span class="dt">repos =</span> <span class="kw">c</span>(<span class="st">&quot;http://yihui.name/xran&quot;</span>, <span class="st">&quot;http://cran.rstudio.com&quot;</span>)
)</code></pre></div>
<p>Remember each Rmd file contains one and only one chapter.</p>
<!--chapter:end:index-->
</div>
<div id="intro" class="section level1">
<h1><span class="header-section-number">2</span> Introduction</h1>
<p>You can label chapter and section titles using <code>{#label}</code> after them, e.g., we can reference Chapter @ref(intro). If you do not manually label them, there will be automatic labels anyway, e.g., Chapter @ref(methods).</p>
<p>Figures and tables with captions will be placed in <code>figure</code> and <code>table</code> environments, respectively.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, .<span class="dv">1</span>, .<span class="dv">1</span>))
<span class="kw">plot</span>(pressure, <span class="dt">type =</span> <span class="st">&#39;b&#39;</span>, <span class="dt">pch =</span> <span class="dv">19</span>)</code></pre></div>
<div class="figure" style="text-align: center">
<img src="book_files/figure-html/nice-fig-1.png" alt="(\#fig:nice-fig)Here is a nice figure!" width="80%" />
<p class="caption">
(#fig:nice-fig)Here is a nice figure!
</p>
</div>
<p>Reference a figure by its code chunk label with the <code>fig:</code> prefix, e.g., see Figure @ref(fig:nice-fig). Similarly, you can reference tables generated from <code>knitr::kable()</code>, e.g., see Table @ref(tab:nice-tab).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">knitr::<span class="kw">kable</span>(<span class="kw">head</span>(iris, <span class="dv">20</span>), <span class="dt">caption =</span> <span class="st">&#39;Here is a nice table!&#39;</span>, <span class="dt">booktabs =</span> <span class="ot">TRUE</span>)</code></pre></div>
<table>
<caption>(#tab:nice-tab)Here is a nice table!</caption>
<thead>
<tr class="header">
<th align="right">Sepal.Length</th>
<th align="right">Sepal.Width</th>
<th align="right">Petal.Length</th>
<th align="right">Petal.Width</th>
<th align="left">Species</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">5.1</td>
<td align="right">3.5</td>
<td align="right">1.4</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">4.9</td>
<td align="right">3.0</td>
<td align="right">1.4</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">4.7</td>
<td align="right">3.2</td>
<td align="right">1.3</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">4.6</td>
<td align="right">3.1</td>
<td align="right">1.5</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">5.0</td>
<td align="right">3.6</td>
<td align="right">1.4</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">5.4</td>
<td align="right">3.9</td>
<td align="right">1.7</td>
<td align="right">0.4</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">4.6</td>
<td align="right">3.4</td>
<td align="right">1.4</td>
<td align="right">0.3</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">5.0</td>
<td align="right">3.4</td>
<td align="right">1.5</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">4.4</td>
<td align="right">2.9</td>
<td align="right">1.4</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">4.9</td>
<td align="right">3.1</td>
<td align="right">1.5</td>
<td align="right">0.1</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">5.4</td>
<td align="right">3.7</td>
<td align="right">1.5</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">4.8</td>
<td align="right">3.4</td>
<td align="right">1.6</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">4.8</td>
<td align="right">3.0</td>
<td align="right">1.4</td>
<td align="right">0.1</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">4.3</td>
<td align="right">3.0</td>
<td align="right">1.1</td>
<td align="right">0.1</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">5.8</td>
<td align="right">4.0</td>
<td align="right">1.2</td>
<td align="right">0.2</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">5.7</td>
<td align="right">4.4</td>
<td align="right">1.5</td>
<td align="right">0.4</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">5.4</td>
<td align="right">3.9</td>
<td align="right">1.3</td>
<td align="right">0.4</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">5.1</td>
<td align="right">3.5</td>
<td align="right">1.4</td>
<td align="right">0.3</td>
<td align="left">setosa</td>
</tr>
<tr class="odd">
<td align="right">5.7</td>
<td align="right">3.8</td>
<td align="right">1.7</td>
<td align="right">0.3</td>
<td align="left">setosa</td>
</tr>
<tr class="even">
<td align="right">5.1</td>
<td align="right">3.8</td>
<td align="right">1.5</td>
<td align="right">0.3</td>
<td align="left">setosa</td>
</tr>
</tbody>
</table>
<p>You can write citations, too. For example, we are using the <strong>bookdown</strong> package <span class="citation">(Xie <a href="#ref-R-bookdown">2016</a>)</span> in this sample book, which was built on top of R Markdown and <strong>knitr</strong> <span class="citation">(Xie <a href="#ref-xie2015">2015</a>)</span>.</p>
<!--chapter:end:01-intro-->
</div>
<div id="poly3" class="section level1">
<h1><span class="header-section-number">3</span> Polygons in 3d</h1>
<div id="gis-for-3d" class="section level2">
<h2><span class="header-section-number">3.1</span> GIS for 3D</h2>
<p>GIS data structures are not well suited for generalization, and visualizations and models in 3D require pretty forceful and ad hoc approaches.</p>
<p>Here I show some of the ways 3D is used in GIS and how they relate to the underlying data models</p>
<p>Manifold terrains - overlay, embedding, textures, walls - average planar elevation relative to surface or via attribute, inability of polygons/lines/points to have Z vertex-attribute</p>
<p>Triangulation in manifold terrains, vs. triangulation in manifold drawings, constrained triangulations</p>
<p>TIN-based triangulation</p>
<p>From these examples, I develop several ways of visualizing a simple polygon data set in a more flexible setting.</p>
<p>Colophon? I use the programming environment <code>R</code> for the data manipulation and the creation of this document via several extensions (packages) to base R.</p>
</div>
<div id="polygon-layer" class="section level2">
<h2><span class="header-section-number">3.2</span> Polygon “layer”</h2>
<p>The R package <code>maptools</code> contains an in-built data set called <code>wrld_simpl</code>, which is a basic (and out of date) set of polygons describing the land masses of the world by country. This code loads the data set and plots it with a basic grey-scale scheme for individual countries.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(maptools)
<span class="kw">data</span>(wrld_simpl)
<span class="kw">print</span>(wrld_simpl)
<span class="kw">plot</span>(wrld_simpl, <span class="dt">col =</span> <span class="kw">grey</span>(<span class="kw">sample</span>(<span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length =</span> <span class="kw">nrow</span>(wrld_simpl)))))</code></pre></div>
<p>We also include a print statement to get a description of the data set, this is a <code>SpatialPolgyonsDataFrame</code> which is basically a table of attributes with one row for each country, linked to a recursive data structure holding sets of arrays of coordinates for each individual piece of these complex polygons.</p>
<p>These structures are quite complicated, involving nested lists of matrices with X-Y coordinates. I can use class coercion from polygons, to lines, then to points as the most straightforward way of obtaining every XY coordinate by dropping the recursive hierarchy structure to get at every single vertex in one matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">allcoords &lt;-<span class="st"> </span><span class="kw">coordinates</span>(<span class="kw">as</span>(<span class="kw">as</span>(wrld_simpl, <span class="st">&quot;SpatialLines&quot;</span>), <span class="st">&quot;SpatialPoints&quot;</span>))
<span class="kw">dim</span>(allcoords)
<span class="kw">head</span>(allcoords)  ## print top few rows</code></pre></div>
<p>(There are other methods to obtain all coordinates while retaining information about the country objects and their component “pieces”, but I’m ignoring that for now.)</p>
<p>We need to put these “X/Y” coordinates in 3D so I simply add another column filled with zeroes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">allcoords &lt;-<span class="st"> </span><span class="kw">cbind</span>(allcoords, <span class="dv">0</span>)
<span class="kw">head</span>(allcoords)</code></pre></div>
<p>(Note for non-R users: in R expressions that don’t include assignment to an object with “&lt;-” are generally just a side-effect, here the side effect of the <code>head(allcoords)</code> here is to print the top few rows of allcoords, just for illustration, there’s no other consequence of this code).</p>
</div>
<div id="opengl-in-r" class="section level2">
<h2><span class="header-section-number">3.3</span> OpenGL in R</h2>
<p>In R we have access to 3D visualizations in OpenGL via the <code>rgl</code> package, but the model for data representation is very different so I first plot the vertices of the <code>wrld_simpl</code> layer as points only.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rgl)
<span class="kw">library</span>(rglwidget)  ## allows embedding OpenGL vis in RMarkdown HTML
<span class="kw">plot3d</span>(allcoords, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>) ## smart enough to treat 3-columns as X,Y,Z
subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_wrld&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
<p>Plotting in the plane is one thing, but more striking is to convert the vertices from planar longitude-latitude to Cartesizan XYZ. Define an R function to take “longitude-latitude-height” and return spherical coordinates (we can leave WGS84 for another day).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">llh2xyz &lt;-<span class="st"> </span>
function (lonlatheight, <span class="dt">rad =</span> <span class="dv">6378137</span>, <span class="dt">exag =</span> <span class="dv">1</span>) 
{
    cosLat =<span class="st"> </span><span class="kw">cos</span>(lonlatheight[, <span class="dv">2</span>] *<span class="st"> </span>pi/<span class="dv">180</span>)
    sinLat =<span class="st"> </span><span class="kw">sin</span>(lonlatheight[, <span class="dv">2</span>] *<span class="st"> </span>pi/<span class="dv">180</span>)
    cosLon =<span class="st"> </span><span class="kw">cos</span>(lonlatheight[, <span class="dv">1</span>] *<span class="st"> </span>pi/<span class="dv">180</span>)
    sinLon =<span class="st"> </span><span class="kw">sin</span>(lonlatheight[, <span class="dv">1</span>] *<span class="st"> </span>pi/<span class="dv">180</span>)
    rad &lt;-<span class="st"> </span>(exag *<span class="st"> </span>lonlatheight[, <span class="dv">3</span>] +<span class="st"> </span>rad)
    x =<span class="st"> </span>rad *<span class="st"> </span>cosLat *<span class="st"> </span>cosLon
    y =<span class="st"> </span>rad *<span class="st"> </span>cosLat *<span class="st"> </span>sinLon
    z =<span class="st"> </span>rad *<span class="st"> </span>sinLat
    <span class="kw">cbind</span>(x, y, z)
}

## deploy our custom function on the longitude-latitude values
xyzcoords &lt;-<span class="st"> </span><span class="kw">llh2xyz</span>(allcoords)</code></pre></div>
<p>Now we can visualize these XYZ coordinates in a more natural setting, and even add a blue sphere for visual effect.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot3d</span>(xyzcoords, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>)
<span class="kw">spheres3d</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dt">radius =</span> <span class="dv">6370000</span>, <span class="dt">col =</span> <span class="st">&quot;lightblue&quot;</span>)
subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_wrldxyz&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
<p>This is still not very exciting, since our plot knows nothing about the connectivity between vertices.</p>
</div>
<div id="organization-of-polygons" class="section level2">
<h2><span class="header-section-number">3.4</span> Organization of polygons</h2>
<p>The in-development R package <code>gris</code> provides a way to represent spatial objects as a set of relational tables. I’m leaving out the details because it’s not the point I want to make, but in short a <code>gris</code> object has tables “o” (objects), “b” (for branches), “bXv” (links between branches and vertices) and “v” the vertices.</p>
<p>If we ingest the <code>wrld_simpl</code> layer we get a list with several tables.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gris)  ## devtools::install_github(&quot;mdsumner/gris&quot;)
gobject &lt;-<span class="st"> </span><span class="kw">gris</span>(wrld_simpl)</code></pre></div>
<p>The objects, these are individual countries with several attributes including the <code>NAME</code>. The attribute “.ob0” is a gris-specific one - the “object ID”, there are also “.br0” attributes for branches, and “.vx0” for vertices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gobject$o</code></pre></div>
<p>The branches, these are individual simple, one-piece “ring polygons”. Every object may have one or more branches (branches may be an “island” or a “hole” but this is not currently recorded). Note how branch 1 and 2 (<code>.br0</code>) both belong to object 1 (.ob0), but branch 3 is the only piece of object 2.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gobject$b

<span class="kw">plot</span>(gobject[<span class="dv">1</span>, ], <span class="dt">col =</span> <span class="st">&quot;#333333&quot;</span>)
<span class="kw">title</span>(gobject$o$NAME[<span class="dv">1</span>])
<span class="kw">plot</span>(gobject[<span class="dv">2</span>, ], <span class="dt">col =</span> <span class="st">&quot;#909090&quot;</span>)
<span class="kw">title</span>(gobject$o$NAME[<span class="dv">2</span>])</code></pre></div>
<p>(Antigua and Barbuda sadly don’t get a particularly good picture here, but this is not the point of the story.)</p>
<p>The links between branches and vertices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gobject$bXv</code></pre></div>
<p>This table is required so that we can normalize the vertices by removing any duplicates based on X/Y pairs, a necessary preparation for the triangulation engine used belo (although not by the visualization). (Note that we could also normalize branches for objects, since multiple objects might use the same branch - but again off-topic).</p>
<p>Finally, the vertices themselves. Here we only have X and Y, but these table structures can hold any number of attributes and of many types.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gobject$v</code></pre></div>
<p>The normalization is only relevant for particular choices of vertices, so if we had X/Y/Z in use there might be a different version of “unique”. I think this is a key point for flexibility, some of these tasks must be done on-demand and some ahead of time.</p>
<p>Indices here are numeric, but there’s actually no reason that they couldn’t be character or other identifier. Under the hood the <code>dplyr</code> package is in use for doing straightforward (and fast!) table manipulations including joins between tables and filtering on values.</p>
</div>
<div id="more-3d-already" class="section level2">
<h2><span class="header-section-number">3.5</span> More 3D already!</h2>
<p>Why go to all this effort just for a few polygons? The structure of the <code>gris</code> objects gives us much more flexibility, so I can for example store the XYZ Cartesian coordinates right on the same data set. I don’t need to recursively visit nested objects, it’s just a straightforward calculation and update - although we’re only making a simple point, this could be generalized a lot more for user code.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gobject$v$zlonlat &lt;-<span class="st"> </span><span class="dv">0</span>
do_xyz &lt;-<span class="st"> </span>function(table) {
  xyz &lt;-<span class="st"> </span><span class="kw">llh2xyz</span>(dplyr::<span class="kw">select</span>(table, x, y, zlonlat))
  table$X &lt;-<span class="st"> </span>xyz[,<span class="dv">1</span>]
  table$Y &lt;-<span class="st"> </span>xyz[,<span class="dv">2</span>]
  table$Z &lt;-<span class="st"> </span>xyz[,<span class="dv">3</span>]
  table
}

gobject$v &lt;-<span class="st"> </span><span class="kw">do_xyz</span>(gobject$v)

gobject$v</code></pre></div>
<p>I now have XYZ coordinates for my data set, and so for example I will extract out a few nearby countries and plot them. First plot in the traditional way, using the default “evenodd” rule used by R’s <code>polypath()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">localarea &lt;-<span class="st"> </span>gobject[gobject$o$NAME %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Australia&quot;</span>, <span class="st">&quot;New Zealand&quot;</span>), ]
## plot in traditional 2d
<span class="kw">plot</span>(localarea, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;dodgerblue&quot;</span>, <span class="st">&quot;firebrick&quot;</span>))</code></pre></div>
<p>The plot is a bit crazy since parts of NZ that are over the 180 meridian skews everything, and we could fix that easily by modifiying the vertex values for longitude, but it’s more sensible in 3D.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot3d</span>(localarea$v$X, localarea$v$Y, localarea$v$Z, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>)
subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_wrldoznz&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
<p>Finally, to get to the entire point of this discussion let’s triangulate the polygons and make a nice plot of the world.</p>
<p>The R package <code>RTriangle</code> wraps Richard Shewchuk’s Triangle library, allowing constrained Delaunay triangulations. To run this we need to make a Planar Straight Line Graph from the polygons, but this is fairly straightforward by tracing through paired vertices in the data set. The key parts of the PSLG are the vertices <code>P</code> and the segment indexes <code>S</code> defining paired vertices for each line segment. This is a “structural” index where the index values are bound to the actual size and shape of the vertices, as opposed to a more general but perhaps less efficient relational index.</p>
<pre class="rr"><code>pslgraph &lt;- mkpslg(gobject)
dim(pslgraph$P)
range(pslgraph$S)
head(pslgraph$P)
head(pslgraph$S)</code></pre>
<p>The PSLG is what we need for the triangulation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tri &lt;-<span class="st"> </span>RTriangle::<span class="kw">triangulate</span>(pslgraph)</code></pre></div>
<p>The triangulation vertices (long-lat) can be converted to XYZ, and plotted.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xyz &lt;-<span class="st"> </span><span class="kw">llh2xyz</span>(<span class="kw">cbind</span>(tri$P, <span class="dv">0</span>))
<span class="kw">triangles3d</span>(xyz[<span class="kw">t</span>(tri$T), ], <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>)
subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_wrld_polyxyz&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
<p>These are very ugly polygons since there’s no internal vertices to carry the curvature of this sphere. This is the same problem we’d face if we tried to drape these polygons over topography, as some point we need internal structure.</p>
<p>Luckily Triangle can set a minimum triangle size. We set a constant minimum area, which means no individual triangle can be larger in area than so many “square degrees”. This gives a lot more internal structure so the polygons are more elegantly draped around the surface of the sphere. (There’s not really enough internal structure added with this minimum area, but I’ve kept it simpler to make the size of this document more manageable).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tri &lt;-<span class="st"> </span>RTriangle::<span class="kw">triangulate</span>(pslgraph, <span class="dt">a =</span> <span class="dv">9</span>)  ## a (area) is in degrees, same as our vertices
xyz &lt;-<span class="st"> </span><span class="kw">llh2xyz</span>(<span class="kw">cbind</span>(tri$P, <span class="dv">0</span>))
<span class="kw">triangles3d</span>(xyz[<span class="kw">t</span>(tri$T), ], <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>)
subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_wrld_surfacexyz&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
<p>We still can’t identify individual polygons as we smashed that information after putting the polygon boundary segments through the triangulator. With more careful work we could build a set of tables to store particular triangles between our vertices and objects, but to finish this story I just loop over each object adding them to the scene.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## loop over objects
cols &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">grey</span>(<span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length =</span> <span class="kw">nrow</span>(gobject$o))))
for (iobj in <span class="kw">seq</span>(<span class="kw">nrow</span>(gobject$o))) {
  pslgraph &lt;-<span class="st"> </span><span class="kw">mkpslg</span>(gobject[iobj, ])
  tri &lt;-<span class="st"> </span>RTriangle::<span class="kw">triangulate</span>(pslgraph, <span class="dt">a =</span> <span class="dv">9</span>)  ## a is in units of degrees, same as our vertices
  xyz &lt;-<span class="st"> </span><span class="kw">llh2xyz</span>(<span class="kw">cbind</span>(tri$P, <span class="dv">0</span>))
  <span class="kw">triangles3d</span>(xyz[<span class="kw">t</span>(tri$T), ], <span class="dt">col =</span> cols[iobj])
}

subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_wrld_surfaceobjects&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
<p>Include a button for the animation …</p>
</div>
<div id="github-sfr" class="section level2">
<h2><span class="header-section-number">3.6</span> Github, sfr</h2>
<p>There is ongoing work to upgrade R’s Spatial support, but this is still wedded to the basic flat and dumb polygonal model used by open source projects.</p>
</div>
<div id="image-textures" class="section level2">
<h2><span class="header-section-number">3.7</span> Image textures</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## marmap has some topography
<span class="kw">library</span>(marmap)
<span class="kw">data</span>(<span class="st">&quot;hawaii&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;marmap&quot;</span>)
r &lt;-<span class="st"> </span>marmap::<span class="kw">as.raster</span>(hawaii)
## but is otherwise undesirable so we unload it
<span class="kw">unloadNamespace</span>(<span class="st">&quot;marmap&quot;</span>)
<span class="kw">library</span>(dismo)
gm &lt;-<span class="st"> </span><span class="kw">gmap</span>(r, <span class="dt">type =</span> <span class="st">&quot;satellite&quot;</span>, <span class="dt">scale =</span> <span class="dv">2</span>)
<span class="co">#gm &lt;- raster()</span>
## this is our texture
paletteim2RGB &lt;-<span class="st"> </span>function(x) {
  ct &lt;-<span class="st">  </span><span class="kw">col2rgb</span>(x@legend@colortable[<span class="kw">values</span>(x) +<span class="st"> </span><span class="dv">1</span>])

  <span class="kw">setValues</span>(<span class="kw">brick</span>(x, x, x), <span class="kw">t</span>(ct))
}
<span class="kw">library</span>(rgdal)
texture &lt;-<span class="st"> </span><span class="kw">writeGDAL</span>(<span class="kw">as</span>(<span class="kw">paletteim2RGB</span>(gm), <span class="st">&quot;SpatialGridDataFrame&quot;</span>), <span class="st">&quot;texture.png&quot;</span>, <span class="dt">drivername =</span> <span class="st">&quot;PNG&quot;</span>, <span class="dt">type =</span> <span class="st">&quot;Byte&quot;</span>)

<span class="kw">library</span>(gris)
<span class="kw">library</span>(rgl)
<span class="kw">library</span>(rglwidget)
b &lt;-<span class="st"> </span><span class="kw">bgl</span>(r, r)
tcoords &lt;-<span class="st"> </span><span class="kw">xyFromCell</span>(<span class="kw">setExtent</span>(gm, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>)), <span class="kw">cellFromXY</span>(gm, <span class="kw">project</span>(<span class="kw">t</span>(b$vb[<span class="dv">1</span>:<span class="dv">2</span>, ]), <span class="kw">projection</span>(gm))))
<span class="kw">aspect3d</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="fl">0.0001</span>)
<span class="co">#shade3d(b, col = &quot;white&quot;, texture= texture, texcoords = tcoords[b$ib, ])</span>

<span class="kw">quads3d</span>(<span class="kw">t</span>(b$vb[<span class="dv">1</span>:<span class="dv">3</span>, b$ib]), <span class="dt">col =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">texture=</span> texture, <span class="dt">texcoords =</span> tcoords[b$ib, ])
subid &lt;-<span class="st"> </span><span class="kw">currentSubscene3d</span>()
<span class="kw">rglwidget</span>(<span class="dt">elementId=</span><span class="st">&quot;plot3d_texture&quot;</span>)
<span class="kw">rgl.close</span>()</code></pre></div>
</div>
<div id="polygon-pathologies" class="section level2">
<h2><span class="header-section-number">3.8</span> Polygon pathologies</h2>
<p>Orthodromes, loxodromes.</p>
<p>Densifying vertices</p>
<p>Projection boundaries</p>
<p>D3 approach to curvature</p>
</div>
<div id="real-world-topography" class="section level2">
<h2><span class="header-section-number">3.9</span> Real world topography</h2>
<p>A simplistic layer of country polygons wrapped around a sphere is not very practical. Here we show the techniques applied above to build a relief map.</p>
<p>Extract a polygon map for Tasmania.</p>
<!--chapter:end:02-poly3d-->
<div id="refs" class="references">
<div id="ref-xie2015">
<p>Xie, Yihui. 2015. <em>Dynamic Documents with R and Knitr</em>. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. <a href="http://yihui.name/knitr/" class="uri">http://yihui.name/knitr/</a>.</p>
</div>
<div id="ref-R-bookdown">
<p>———. 2016. <em>Bookdown: Authoring Books with R Markdown</em>. <a href="https://github.com/rstudio/bookdown" class="uri">https://github.com/rstudio/bookdown</a>.</p>
</div>
</div>
</div>
</div>
<!--token:body:end-->


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
